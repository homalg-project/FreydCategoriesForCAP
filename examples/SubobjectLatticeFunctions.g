## Helper functions for computing with lattices of subobjects

## Intput: two subobjects
## Output: their intersection
IntS := function( sub1, sub2 )
    local intersection;
    
    intersection := MorphismFromFiberProductToSink( [ sub1, sub2 ] );
    
    SetIsMonomorphism( intersection, true );
    
    return intersection;
    
end;

## Intput: two subobjects
## Output: their sum
SumS := function( sub1, sub2 )
    local subobject_sum;
    
    subobject_sum := ImageEmbedding( UniversalMorphismFromDirectSum( [ sub1, sub2 ] ) );
    
    SetIsMonomorphism( subobject_sum, true );
    
    return subobject_sum;
    
end;

## Intput: a list of subobjects
## Output: all subobjects in the subobject lattice generated by the input (if it is finite)
GenerateSubobjects := function( input )
    local debug_output, print_func, all, new_objs, test, test_func, x, y, t, counter, s_counter, size, word_list, int, sum, elem;
    
    if IsEmpty( input ) then
        
        return input;
        
    fi;
    
    debug_output := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "debug_output", false );
    
    print_func := function( str )
        
        if debug_output then
            
            Print( str );
            
        fi;
        
    end;
    
    counter := 0;
    
    for elem in input do
        
        counter := counter + 1;
        
        elem!.id := counter;
        
        SetIsMonomorphism( elem, true );
        
    od;
    
    all := ShallowCopy( input );;
    
    new_objs := ShallowCopy( input );
    
    test_func := function( t, all )
        local r;
        
        r := ForAny( all, z -> IsEqualAsSubobjects( t, z ) );
        
        return r;
        
    end;
    
    word_list := [];
    
    while true do
        
        test := [];
        
        # join and meet of all with new_objs
        
        size := Size( all ) * Size( new_objs );
        s_counter := 0;
        
        for x in all do
            for y in new_objs do
                
                if x!.id <> y!.id then
                    
                    if not Set( [ x!.id, y!.id ] ) in word_list then
                        
                        Add( word_list, Set( [ x!.id, y!.id ] ) );
                        
                        int := IntS( x, y );
                        
                        Add( test, int );
                        
                        sum := SumS( x, y );
                            
                        Add( test, sum );
                        
                        s_counter := s_counter + 1;
                        
                        print_func( Concatenation( "\r", String( s_counter ), "/", String( size ), "\c" ) );
                        
                    fi;
                    
                fi;
                
            od;
        od;
        
        new_objs := [];
        
        print_func( "\n\c" );
        
        print_func( String( Size( test ) ) );
        
        
        for t in test do
            
            if not test_func( t, all ) then
                counter := counter + 1;
                print_func( Concatenation( "(N=", String( counter ),")\c" ) );
                t!.id := counter;
                Add( all, t );
                Add( new_objs, t );
            else
                print_func( "-\c" );
            fi;
            
        od;
        
        if IsEmpty( new_objs ) then
            break;
        else
            print_func( "S\n\c" );
        fi;
        
    od;
    
    return all;
    
end;
